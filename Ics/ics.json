[{
    "activities": [
      "A tutorial introduction and Getting Started",
      "A tutorial introduction and Getting Started - Quiz",
      "Variables and Arithmetic Expressions",
      "Variables and Arithmetic Expressions - Quiz",
      "The For Statement",
      "The For Statement - Quiz",
      "Symbolic Constants",
      "Symbolic Constants - Quiz",
      "Character input and output",
      "Character input and output - Quiz",
      "Arrays",
      "Arrays - Quiz",
      "Functions",
      "Functions - Quiz",
      "Arguments - Call by value",
      "Arguments - Call by value - Quiz",
      "Character Arrays",
      "Character Arrays - Quiz",
      "External variables and scope",
      "External variables and scope - Quiz",
      "Assignment-1",
      "Assignment-2"
    ],
    "desc": "<b>Module Overview:</b><br><br>The aim of this module is to show the essential elements of the language in writing the basic programs but without bogged down in details, rules and exceptions. We want to get you as quickly as possible to the point where you can write useful programs, and to do that we have to concentrate on the basics: variables and constants, arithmetic, control flow, functions, and the rudiments of input and output. We are intentionally leaving out of this chapter features of C that are important for writing bigger programs. <br>In any case, experienced programmers should be able to extrapolate from the material in this chapter 'to their own programming needs. Beginners should supplement it by writing small, similar programs of their own<br><br><b>Learning Objectives:</b><ol><li>Identify the purpose of core elements of the programming.</li><li>Explain the input reading and output formatting that can be done using input and output statements.</li><li>Learn how to repeat a set of statements using for loop.</li><li>Learn the scope of variables based on their declaration and the storage classes.</li><li>Identify which part of the code can be modularise to improve readability.</li></ol>",
    "id": 1,
    "name": "Tutorial Introduction"
  },
  {
    "activities": [
      "Variables",
      "Variables - Quiz",
      "Data types and sizes",
      "Data types and sizes - Quiz",
      "Constants",
      "Constants - Quiz",
      "Declarations",
      "Declarations - Quiz",
      "Arithmetic Operators",
      "Relational and Logical Operators",
      "Type Conversions",
      "Operators and Type conversions - Quiz",
      "Increment and Decrement Operators",
      "Increment and Decrement Operators - Quiz",
      "Bitwise operators",
      "Bitwise operators - Quiz",
      "Assignment operators and Expressions",
      "Conditional Expressions",
      "Precedence and order of evaluations",
      "Operators, Expressions and Precedence - Quiz",
      "Assignment-1",
      "Assignment-2",
      "Assignment-3"
    ],
    "desc": "<b>Module Overview</b><br><br>This module introduces to various core elements of the programming. Variables and constants are the basic data objects manipulated in a program. Declarations list the variables to be used, and state what type they have and perhaps what their initial values are. Operators specify what is to be done to them. Expressions combine variables and constants to produce new values. The type of an object determines the set of values it can have and what operations can be performed on it.<br><br><b>Learning Objectives</b><ol><li>Define and declare variables.</li><li>Define constants</li><li>Perform arithmetic operations</li><li>Make use of different operators such as relational and conditional operators, increment and decrement operators, bitwise operators</li><li>Evaluate expressions and its order of precedence</li></ol>",
    "id": 2,
    "name": "Data types, Variables, Constants, Operators"
  },
  {
    "activities": [
      "Bits Bytes and Integers Part - 1.1",
      "Bits Bytes and Integers Part - 1.1 Quiz",
      "Bits Bytes and Integers Part - 1.2",
      "Bits Bytes and Integers Part - 1.2 Quiz",
      "Bits Bytes and Integers Part - 1.3",
      "Bits Bytes and Integers Part - 1.3 - Quiz",
      "Data Lab - Code Camp",
      "Assignment-1"
    ],
    "desc": "<b>Module Overview:</b><br><br>In this module you are going to learn, arithmetic, emphasizing the properties of unsigned and two’s-complement number representations that affect programmers how numbers are represented and therefore what range of values can be encoded for a given word size. We consider the effect of casting between signed and unsigned numbers.<br><br><b>Learning Objectives:</b><ol><li>Explain how the information is stored as bits in memory.</li><li>Explain boolean algebra on bits using &, |, ^, !</li><li>Perform bit level manipulations</li><li>Make use of bitwise operators to finish of the datalab.</li></ol>",
    "id": 3,
    "name": "Data Lab - 1"
  },
  {
    "activities": [
      "Video on Bits Bytes and Integers Part - 2.1",
      "Quiz on Bits Bytes and Integers Part - 2.1",
      "Video on Bits Bytes and Integers Part - 2.2",
      "Quiz on Bits Bytes and Integers Part - 2.2",
      "Video on  Bits Bytes and Integers Part - 2.3",
      "Quiz on  Bits Bytes and Integers Part - 2.3",
      "Video on Floating Point - Optional",
      "Quiz on Floating Point",
      "Assignment-1",
      "Assignment-2"
    ],
    "desc": "<b>Module Overview:</b><br><br>In this module you are going to learn the mathematical properties of arithmetic operations such as addition, multiplication, difference and modulo. Novice programmers are often surprised to learn that the (two’s-complement) sum or product of two positive numbers can be negative. On the other hand, two’s complement arithmetic satisfies the algebraic properties of a ring, and hence a compiler can safely transform multiplication by a constant into a sequence of shifts and adds. We use the bit-level operations of C to demonstrate the principles and applications of Boolean algebra.<br><br><b>Learning Objectives:</b><ol><li>Demonstrate how  signed and unsigned addition of two numbers are performed.</li><li>Identify overflows (truncation and expanding) when arithmetic operations are performed.</li><li>Develop logic and Implement functions using bitwise operators as part of the Lab assignment</li></ol>",
    "id": 4,
    "name": "Data Lab - 2"
  },
  {
    "activities": [
      "Statements and Blocks, if-else, else-if and Switch",
      "Quiz on Statements and Blocks, if-else, else-if and Switch",
      "Loops while and for and do - while",
      "Quiz on Loops while and for and do - while",
      "Break, Continue and Goto Labels",
      "Quiz on Break, Continue and Goto Labels",
      "Basics of functions",
      "Quiz on Basics of functions",
      "Functions returning non-integers",
      "Quiz on Functions returning non-integers",
      "External variables",
      "Quiz on External variables",
      "Scope rules",
      "Quiz on Scope rules",
      "Header files",
      "Quiz on Header files",
      "Static and Register Variables",
      "Quiz on Static and Register Variables",
      "Block structure and Initialization",
      "Quiz on Block structure and Initialization",
      "Recursion",
      "Quiz on Recursion",
      "The C Preprocessor",
      "Quiz on The C Preprocessor",
      "Assignment-1",
      "Assignment-2",
      "Assignment-3"
    ],
    "desc": "<b>Module Overview:</b><br><br>In this module you are going to learn about the control flow statements in C language. It’s just very similar to Java which you have already learnt. The control-flow statements of a language specify the order in which computations are performed. We have already met the most common control-flow constructions in earlier examples during the tutorial introduction; here we will complete the set, and be more precise about the ones discussed before.<br><br><b>Learning Objectives:</b><ol><li>Explain how block of statements can be created.</li><li>Perform decision making using if and else.</li><li>Trace the execution of for, while and do-while</li><li>Discuss the structure of nested loops</li><li>Differentiate between break and continue.</li><li>Discuss the pros and cons of Goto Statements</li><li>Explain how the code converts to machine code (Assembly Language)</li><li>Explain the purpose of functions.</li><li>Declare and define functions in your programs</li><li>Differentiate between various types of function prototypes</li><li>Identify the scope of variables</li><li>Explain the importance of recursive functions.</li></ol>",
    "id": 5,
    "name": "Functions and Control Flow"
  },
  {
    "activities": [
      "Introduction",
      "Quiz on Introduction",
      "Processes",
      "Quiz on Processes",
      "CPU Scheduling",
      "Assignment-1",
      "Video on Bomb Lab - Machine Level Programming - Basics",
      "Quiz on Bomb Lab - Machine Level Programming - Basics",
      "Video on Bomb Lab - Machine Level Programming - Control",
      "Quiz on Bomb Lab - Machine Level Programming - Control",
      "Bomb Lab - Diffuse Phase - 1",
      "Assignment-1"
    ],
    "desc": "<b>Module Overview:</b><br><br>An operating system acts as an intermediary between the user of a computer and the computer hardware. The purpose of an operating system is to provide an environment in which a user can execute programs in a convenient and efficient manner.<br><br>An operating system is software that manages the computer hardware. The hardware must provide appropriate mechanisms to ensure the correct operation of the computer system and to prevent user programs from interfering with the proper operation of the system<br><br>Early computers allowed only one program to be executed at a time. This program had complete control of the system and had access to all the system’s resources. In contrast, contemporary computer systems allow multiple programs to be loaded into memory and executed concurrently. This evolution required firmer control and more compartmentalization of the various programs; and these needs resulted in the notion of a process, which is a program in execution. A process is the unit of work in a modern time-sharing system.<br><br><b>Learning Objectives:</b><ol><li>To describe the basic organization of computer systems.</li><li>To provide a grand tour of the major components of operating systems.</li><li>To give an overview of the many types of computing environments.</li><li>To explore several open-source operating systems</li><li>To introduce the notion of a process—a program in execution, which forms the basis of all computation.</li><li>To describe the various features of processes, including scheduling, creation, and termination.</li><li>To explore interprocess communication using shared memory and message passing.</li><li>To describe communication in client–server systems.</li><li>Understand and trace the assembly code.",
    "id": 6,
    "name": "OS Concepts, Bomb Lab Diffuse of Phase - 1"
  },
  {
    "activities": [
      "Pointers and Addresses",
      "Quiz on Pointers and Addresses",
      "Pointers and Functions Arguments",
      "Quiz on Pointers and Functions Arguments",
      "Pointers and Arrays",
      "Quiz on Pointers and Arrays",
      "Address Arithmetic",
      "Quiz on Address Arithmetic",
      "Character Pointers and Function",
      "Quiz on Character Pointers and Function",
      "Pointer Arrays and Pointers to Pointers",
      "Quiz on Pointer Arrays and Pointers to Pointers",
      "Multi-dimensional Arrays",
      "Quiz on Multi-dimensional Arrays",
      "Initialization of Pointer arrays and Pointers vs Multi-Dimensional Arrays",
      "Quiz on Initialization of Pointer arrays and Pointers vs Multi-Dimensional Arrays",
      "Command Line arguments",
      "Quiz on Command Line arguments",
      "Pointers to functions",
      "Complicated Declarations",
      "Assignment-1",
      "Assignment-2",
      "Assignment-3",
      "Assignment-4"
    ],
    "desc": "<b>Module Overview:</b><br>A pointer is a variable that contains the address of a variable. Pointers are much used in C, partly ,because they are sometimes the only way to express a computation, and partly because they usually lead to more compact and efficient code than can be obtained in other ways. Pointers and arrays are closely related; this chapter also explores this relationship and shows how to exploit it. Let’s get started.<br><br><b>Learning Objectives:</b><br><br><ol><li>Explain the importance of pointers</li><li>Differentiate between pointer and address</li><li>Perform arithmetic operations on pointers and identify the differences between general arithmetic operations and pointer arithmetic operations.</li><li>Make use of command line arguments to read data and give as input to your program from command line</li><li>Explain the pointer arrays and how it can be useful.</li></ol>",
    "id": 7,
    "name": "Pointers and Arrays"
  },
  {
    "activities": [
      "Basics of Structures",
      "Quiz on Basics of Structures",
      "Structures and Functions",
      "Quiz on Structures and Functions",
      "Arrays of Structures",
      "Quiz on Arrays of Structures",
      "Pointers to structures",
      "Quiz on Pointers to structures",
      "Self referential structures",
      "Quiz on Self referential structures",
      "Typedef",
      "Quiz on Typedef",
      "Unions and Bit fields",
      "Quiz on Unions and Bit fields",
      "Assignment-1",
      "Assignment-2",
      "Assignment-3"
    ],
    "desc": "<b>Module Overview</b><br>A structure is a collection of one or more variables, possibly of different types, grouped together under a single name for convenient handling. (Structures are called \"records\" in some languages, notably Pascal.) Structures help to organize complicated data, particularly in large programs, because they permit a group of related variables to be treated as a unit instead of as separate entities. Let’s get started.<br><br><b>Learning Objectives:</b><ol><li>Identify user defined data types</li><li>Define and Create user defined data types using structures</li><li>Implement how structures can be passed as arguments to functions</li><li>Define array of structures.</li><li>Access the members of structures.</li></ol>",
    "id": 8,
    "name": "Structures"
  },
  {
    "activities": [
      "Video on The Memory Hierarchy - Part 1",
      "Quiz on The Memory Hierarchy - Part 1",
      "Video on The Memory Hierarchy - Part 2",
      "Quiz on The Memory Hierarchy - Part 2",
      "Video on The Cache Memories - Part 1 (Direct Mapped Caches)",
      "Quiz on The Cache Memories - Part 1 (Direct Mapped Caches)",
      "Video on The Cache Memories - Part 2 (E way Set Associative Cache)",
      "Quiz on The Cache Memories - Part 2 (E way Set Associative Cache)",
      "Video on The Cache Memories - Part 2 (Performance impacts of caches)",
      "Quiz on The Cache Memories - Part 2 (Performance impacts of caches)",
      "Skim the text book for cache memories",
      "Cache Lab Handout - Coding",
      "Assignment-1"
    ],
    "desc": "<b>Module Overview:</b>In practice, a memory system is a hierarchy of storage devices with different capacities, costs, and access times. CPU registers hold the most frequently used data. Small, fast cache memories nearby the CPU act as staging areas for a subset of the data and instructions stored in the relatively slow main memory. The main memory stages data stored on large, slow disks, which in turn often serve as staging areas for data stored on the disks or tapes of other machines connected by networks. Let’s get started in detail.<br>It's also a fun in simulating the cache lab. Happy Coding.<br><br><b>Learning Objectives:</b><ol><li>Explain the memory hierarchy.</li><li>Explain the importance of Cache memories and how it can improvise the execution of the instructions.</li><li>Understand the different types of cache memory such as Direct Mapped cache, Set Associative cache and etc</li><li>Explain the importance of spatial locality.</li><li>Understand Cache hit, Cache miss and Cache eviction.</li></ol>",
    "id": 9,
    "name": "Cache Lab - 1"
  },
  {
    "activities": [
      "Cache Lab Handout - Coding",
      "Assignment-1"
    ],
    "desc": "<b>Module Overview:</b><br><br>You are going to simulate the working principles of cache by implementing the cache hits and misses for different kinds of caches such as Direct Mapped Cache, Set Associative Cache and Full Associative caches.<br><br><b>Learning Objectives:</b><ol><li>Define the data type for handling cache memory</li><li>Read the inputs for the program using command line arguments</li><li>Implement the functions for load, store and modify to handle the operations on cache memory</li><li>Implement the cache hit, miss and evictions</li></ol>",
    "id": 10,
    "name": "Cache Lab - 2"
  },
  {
    "activities": [
      "Cache Lab Handout - Coding",
      "Assignment-1",
      "Assignment-2"
    ],
    "desc": "<b>Module Overview:</b><br><br>You are going to program the code for the cache lab implementing the cache hits and misses for different kinds of caches such as Direct Mapped Cache, Set Associative Cache and Full Associative caches.<br><br><b>Learning Objectives:</b><ol><li>Define the data type for handling cache memory</li><li>Read the inputs for the program using command line arguments</li><li>Implement the functions for load, store and modify to simulate cache memory.</li><li>Implement the cache hit, miss and evictions.</li></ol>",
    "id": 11,
    "name": "Cache Lab - 3"
  },
  {
    "activities": [
      "Mass Storage Structure",
      "Quiz on Mass Storage Structure",
      "Video on Bomb Lab - Machine Level Programming - III Procedures",
      "Video on Machine Level Programming - IV - Data",
      "Bomb Lab - Diffuse Phase - 3",
      "Video on Machine Level Programming - V - Advanced Topics",
      "Quiz on Machine Level Programming V - Advanced Topics",
      "Code camp on Attack Lab - Phase 1, 2",
      "Assignment-1",
      "Assignment-2",
      "Assignment-3"
    ],
    "desc": "<b>Module Overview:</b><br><br>The file system can be viewed logically as consisting of three parts. We examine the user and programmer interface to the file system. Here We begin a discussion of file systems at the lowest level: the structure of secondary storage. We first describe the physical structure of magnetic disks and magnetic tapes. We then describe disk-scheduling algorithms, which schedule the order of disk I/Os to maximize performance. Next, we discuss disk formatting and management of boot blocks, damaged blocks, and swap space.<br><br><b>Learning Objectives:</b><ol><li>To describe the physical structure of secondary storage devices and its effects on the uses of the devices</li><li>To explain the performance characteristics of mass-storage devices</li><li>To evaluate disk scheduling algorithms</li></ol>",
    "id": 12,
    "name": "OS Concepts, Bomb lab diffuse of Phase 2 and 3"
  },
  {
    "activities": [
      "Video on Exceptional Control Flow - Processes(Part - 1)",
      "Exceptional Control Flow - Processes(Part - 1) Reading",
      "Quiz on Exceptional Control Flow - Processes(Part - 1)",
      "Video on Exceptional Control Flow - Processes(Part - 2)",
      "Exceptional Control Flow - Processes(Part - 2) Reading",
      "Quiz on Exceptional Control Flow - Processes(Part - 2)",
      "Shell Lab handout",
      "Assignment-1"
    ],
    "desc": "<b>Module Overview:</b><br>Up to this point in your study of systems, you have learned how applications interact with the hardware. From this week through the rest of the course is a pivotal in the sense that you will begin to learn how your applications interact with the operating system. Interestingly, these interactions all revolve around ECF. We describe the various forms of ECF that exist at all levels of a computer system. We start with exceptions, which lie at the intersection of the hardware and the operating system. We also discuss system calls, which are exceptions that provide applications with entry points into the operating system. We then move up a level of abstraction and describe processes and signals, which lie at the intersection of applications and the operating system. Finally, we discuss nonlocal jumps, which are an application-level form of ECF.<br><br><b>Learning Objectives:</b><ol><li>Explain what is exceptional control flow</li><li>Define Exceptions and how it can be handled.</li><li>Define System call</li><li>Explain two key abstractions of processes: Logical control flow and private address space</li><li>Understand the illusion of multiprocessing</li></ol>",
    "id": 13,
    "name": "Shell Lab, Exceptional Control Flow: Processes"
  },
  {
    "activities": [
      "Video on Exceptional Control Flow - Processes(Part - 3)",
      "Exceptional Control Flow - Processes(Part - 3 ) Reading",
      "Quiz on Exceptional Control Flow - Processes(Part - 3 )",
      "Video on Exceptional Control Flow - Processes Part - 4)",
      "Exceptional Control Flow -  Processes (Part - 4) Reading",
      "Quiz on Exceptional Control Flow -  Processes (Part - 4)",
      "Shlab-Handout Code review",
      "Assignment-1",
      "Assignment-2"
    ],
    "desc": "<b>Module Overview:</b><br>In this module we are going to discuss system calls, which are exceptions that provide applications with entry points into the operating system. We then move up a level of abstraction and describe processes and signals, which lie at the intersection of applications and the operating system. Finally, we discuss nonlocal jumps, which are an application-level form of ECF.<br><br><b>Learning Objectives:</b><br><ol><li>Understand and implement system call error handling</li><li>Identify the various process states such as Running, Stopped and Terminated.</li><li>Create child process using fork system call.</li><li>Explain Zombies and Reaping child processes.</li><li>Implement execve system call to execute user defined programs.</li></ol>",
    "id": 14,
    "name": "Exceptional Control Flow: Processes"
  },
  {
    "activities": [
      "Video on Exceptional Control Flow - Signals (Part - 1)",
      "Exceptional Control Flow - Signals (Part - 1) Reading",
      "Quiz on Exceptional Control Flow - Signals (Part - 1)",
      "Shell Lab - Code part 2",
      "Activity - 5",
      "Assignment-1",
      "Assignment-2",
      "Assignment-3"
    ],
    "desc": "<b>Module Overview:</b><br>To this point in our study of exceptional control flow, we have seen how hardware and software cooperate to provide the fundamental low-level exception mechanism. We have also seen how the operating system uses exceptions to support a form of exceptional control flow known as the process context switch. In this section, we will study a higher-level software form of exceptional control flow, known as a Unix signal, that allows processes and the kernel to interrupt other processes.<br><br><b>Learning Objectives:</b><ol><li>Understand the linux process hierarchy.</li><li>Implement your own simple shell by walking through the handout.</li><li>Identify the problems with the simple shell</li><li>Implement eval function to drive the execution of your simple shell</li><li>Implement various functions such as builtin_cmd based on the instructions in the handout given</li></ol>",
    "id": 15,
    "name": "Exceptional Control Flow: Signals"
  }
]